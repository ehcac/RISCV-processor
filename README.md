# RISCV-processor
a simulator for a simplified RISC-V processor in C++
## Milestone#1
  - Implemented parsing of RISC-V source code
  - Implemented conversion of RISC-V code to equivalent opcodes (hex)
  - Printed output in console
## Milestone#2
  - Created outputs for memory (registers, mian memmory)
  - Displayed pipeline map for each cycle
  - Running code on html website using web assembly via console log
## Milestone#3
  - Added feature of text box for users to input code
  - Created display for regiester values, opcodes, and pipeline map
  - User is able to edit main memory, and register throughout runtime

## To run:
```bash
cd cpp_files

emcc *.cpp -o ../simulator.js \
  -s WASM=1 \
  -s ALLOW_MEMORY_GROWTH=1 \
  -s EXPORTED_RUNTIME_METHODS='["ccall","cwrap"]' \
  -s EXPORT_ES6=0 \
  --bind \
  -std=c++17 \
  -O2

cd ..

# Start a local server
python3 -m http.server 8000
# OR
python -m http.server 8000
```


## Supported Instructions:
LW, SW, SLT, SLL, SLLI, BEQ, BLT

## Project Structure:
- assembler.hpp - contains shared data structures, constants, and global declarations
- instruction_set.cpp - contains the RISC-V instruction definitions
- utils.hpp / utils.cpp - for helper/utility functions (e.g., splitting, conversions, register parsing)
- parser.hpp / parser.cpp - handles reading, and instruction parsing
- encoder.hpp / encoder.cpp - contains functions for translation to opcode
- main.cpp - main program


Design Methodology
- assembler.hpp - contains shared data structures, constants, and global declarations
- encoder.cpp / encoder.hpp - contains functions for translation to opcode
- instruction_set.cpp - contains the RISC-V instruction definitions
- parser.cpp / parser.hpp - handles reading, and instruction parsing
- pipeline_structs.hpp - contains data structures used for pipelining
- utils.cpp / utils.hpp- for helper/utility functions (e.g., splitting, conversions, register parsing)
- simulator.cpp / simulator.hpp - contains functions used for simulator in main

- main.cpp - main file containing simulator functions for HTML

- index.html - main webpage used for GUI
- simulator.js - Javascript code generated by emscripten
- simulator.wasm - WebAssembly code generated by emscripten



AHA Moments

    Since the original program was built with C++, we realized that we could utilize HTML for a GUI through the use of WebAssembly (WASM)

    One big problem was debugging a 32 bit integer

    For example, 320 in binary is 1 0100 0000, but the lower 8 bits are only seen as 64. This made it so that mem 16 contained 64 and mem 17 contained 1.

    Data hazards can be detected by simply looking at the IR values of the previous cycle and instruction since it contains information of registers that needed to be updated

