# RISCV-processor
- A web-GUI simulator for a simplified RISC-V processor in C++
- This program showcases the RISC-V process of running any abritrary RISC-V instruction (within the supported instruction set)
## Supported Instructions:
LW, SW, SLT, SLL, SLLI, BEQ, BLT
## To run:
```bash
cd cpp_files

emcc *.cpp -o ../simulator.js \
  -s WASM=1 \
  -s ALLOW_MEMORY_GROWTH=1 \
  -s EXPORTED_RUNTIME_METHODS='["ccall","cwrap"]' \
  -s EXPORT_ES6=0 \
  --bind \
  -std=c++17 \
  -O2

cd ..

# Start a local server
python3 -m http.server 8000
# OR
python -m http.server 8000
```

## Milestone#1
  - Implemented parsing of RISC-V source code
  - Implemented conversion of RISC-V code to equivalent opcodes (hex)
  - Printed output in console
## Milestone#2
  - Created outputs for memory (registers, mian memmory)
  - Displayed pipeline map for each cycle
  - Running code on html website using web assembly via console log
## Milestone#3
  - Added feature of text box for users to input code
  - Created display for regiester values, opcodes, and pipeline map
  - User is able to edit main memory, and register throughout runtime

## Project Structure:
- assembler.hpp - contains shared data structures, constants, and global declarations
- encoder.cpp / encoder.hpp - contains functions for translation to opcode
- instruction_set.cpp - contains the RISC-V instruction definitions
- parser.cpp / parser.hpp - handles reading, and instruction parsing
- pipeline_structs.hpp - contains data structures used for pipelining
- utils.cpp / utils.hpp- for helper/utility functions (e.g., splitting, conversions, register parsing)
- simulator.cpp / simulator.hpp - contains functions used for simulator in main
<br>

- main.cpp - main file containing simulator functions for HTML

<br>

- index.html - main webpage used for GUI
- simulator.js - Javascript code generated by emscripten
- simulator.wasm - WebAssembly code generated by emscripten

<br>

## Design Methodology
- The program was first written in c++ and the outputs were displayed on the terminal. To complete the GUI requirement the students had utilized WebAssembly to display the output result to HTML websites using emscripten as the compiler. The design of the main.cpp file was simply adapted from a console application to a web-GUI application and its showcased through how the functions were implemented. Through WebAssembly, javascript is able to call the c++ functions and display them as HTML values. Each function responsible for displaying information has a return value of a string.
- HTML, JS, CSS was used as the frontend for its ease of use when creating UI
- C/C++ was used for its memory control and familarity
- WebAssembly was used as a linker between the HTML-C++ code 
## Testing Methodolog
- The program was tested with multiple different RISC-V code snippets to check for compilation. The demo/sample.s file outputs compiles and has the same final state after running the program in rars. 
## AHA Moments
- One big problem was debugging a 32 bit integer For example, 320 in binary is 1 0100 0000, but the lower 8 bits are only seen as 64. This made it so that mem 16 contained 64 and mem 17 contained 1. We ran into this problem when we were testing out different sample files to run to see if our code logic worked. One of these codes made it so that a number was shifted two times to verify that the instruction SLLI was working. Shifting 40 to the left by 2 making it 160, then SLL to shift it once making it 320. The issue with this was that initially to represent each memory location, using 8-bit integers. This was basically representing the low 4 bytes which made it so that the stored binary number 1 0100 0000 was viewed as 0100 0000 in the memory address 16 that was supposed to hold 320 (it instead held 64). Memory location 17 contained 1 which was the upper 4 bytes of memory location 16. We had to change the logic to use full 32-bit word values in the main.cpp file to be able to read 4 consecutive bytes and combine them so that we can see the full integer and not just the first byte. This is also why in the representation of our Memory Editor, you can see that when viewing memory, it shows the Address, Byte, AND the Word. 
- The condition to be able to detect data hazards is simply looking at the IR values of the previous cycle and instruction since it contains information of registers that needed to be updated. This was because each opcode stores the information of the which registers would be affected after running therefore we simply just need to look at the type of register, and the rs1, rs2 to check for any data hazards.

A simulator for a simplified RISC-V processor in C++

## Supported Instructions
LW, SW, SLT, SLL, SLLI, BEQ, BLT

Additional Instructions: ADD, SUB, AND, ADDI

## Design Methodology
assembler.hpp - contains shared data structures, constants, and global declarations

encoder.cpp - contains functions for translation to opcode

encoder.hpp - contains functions for translation to opcode

index.html - main webpage used for GUI

instruction_set.cpp - contains the RISC-V instruction definitions

main.cpp - main file containing simulator functions for HTML

parser.cpp - handles reading, and instruction parsing

parser.hpp - handles reading, and instruction parsing

pipeline_structs.hpp - contains data structures used for pipelining

simulator.cpp - contains functions used for simulator in main

simulator.hpp - contains functions used for other larger functions in simulator.cpp

simulator.js - JavaScript file used for index.html

simulator.wasm - wasm file used for index.html

utils.cpp - for helper/utility functions (e.g., splitting, conversions, register parsing)

utils.hpp - for helper/utility functions (e.g., splitting, conversions, register parsing)

## Testing Methodology
The code was compiled using Emscripten as a way to generate the wasm file needed for the HTML webpage.

Compiling Command: "emcc *.cpp -o ../simulator.js -s WASM=1 -s ALLOW_MEMORY_GROWTH=1 -s EXPORTED_RUNTIME_METHODS='["ccall","cwrap"]' -s EXPORT_ES6=0 --bind -std=c++17 -O2"

The webpage also needed to use Python to connect to a server in order to initialize the simulator module.

Server Command: "python3 -m http.server 8000" OR "python -m http.server 8000"

## AHA Moments
- Since the original program was built with C++, we realized that we could utilize HTML for a GUI through the use of WebAssembly (WASM) 

- One big problem was debugging a 32 bit integer
- For example, 320 in binary is 1 0100 0000, but the lower 8 bits are only seen as 64. This made it so that mem 16 contained 64 and mem 17 contained 1.

- Data hazards can be detected by simply looking at the IR values of the previous cycle and instruction since it contains information of registers that needed to be updated
