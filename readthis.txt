1. parser.cpp (The Logic Overhaul)
Original Logic:
    Ignored any line starting with . (e.g., .data, .word).
    Treat everything as code (.text).
    Calculated addresses sequentially regardless of section.

The Changes:
Directive Awareness: In readAndPreprocess, I removed the check that skipped lines starting with . 
    The parser now reads .data and .word. 

Section Tracking: In buildSymbolTable and parseInstructions, I added a boolean flag inDataSegment. 
    If .data is seen: It switches the address counter to start at 0x00. 
    If .text is seen: It switches the address counter to 0x80. 

Data Extraction (New Function): Added parseDataSection. 
    This function specifically looks for .word directives and extracts their values into a global map DATA_SEGMENT. 
    This allows us to "preload" memory before simulation starts.

2. instruction_set.cpp 
The file now only contains the definitions for LW, SW, SLT, SLL, SLLI, BEQ, BLT.

3. encoder.cpp
Original Logic:
    Basic shifting and OR-ing of values.
    Relied on implicit casting for negative numbers.

The Changes:
Safety Masking: Added explicit bitwise AND masks (e.g., imm & 0xFFF or imm & 0x1F) before shifting.
    AI reason: In C++, right-shifting negative signed integers fills the top bits with 1s (Sign Extension). 
    If we don't mask them before combining them into an unsigned int instruction, those 1s can overwrite other 
    fields (like the opcode or register numbers). This ensures negative branch offsets for BLT/BEQ are encoded safely.

4. main.cpp 
Original Logic:
    Linear Execution: Read File $\to$ Parse $\to$ Print Hex $\to$ Exit.
    No State: It did not store register values or memory.
    
The Changes:
Simulator Integration: Instead of exiting after printing Hex, it now instantiates the RISCV_Simulator class.

Memory Loading: Added a loop that takes the data found in parser.cpp (the .word values) and injects them into the 
                Simulator's memory array using sim.set_memory.

Interactive Menu: Added a while loop that keeps the program running, allowing you to choose:Step (Cycle-by-Cycle).Run All.View Memory.

Visualizers: Added helper functions print_pipeline_state and print_registers to draw the GUI requested by the Case Project (Output Screen #4).

Little Endian Viewer Fix:
    Old (Original Main): Didn't exist.Intermediate
     Main: Showed 1 byte (resulted in 64 instead of 320).
     Current Main: I updated Case 3 to read 4 consecutive bytes and combine them:
        int32_t wordVal = b0 | (b1 << 8) | (b2 << 16) | (b3 << 24);
This ensures you see the full integer value stored in memory.

5. simulator.cpp & simulator.hpp
Pipeline Buffers: Structs (IF/ID, ID/EX, etc.) to hold data between clock cycles.
5-Stage Logic: The step() function that processes WB, MEM, EX, ID, IF in reverse order.
Hazard Detection: Logic to stall the pipeline if a dependency is found (Data Hazard) or flush it if a branch is taken (Control Hazard).
Structural Hazard: Separating data_memory (Array) from inst_memory (Map).